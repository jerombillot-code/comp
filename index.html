<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bot Trading Multi-Crypto Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        body {
            background: #000000;
            min-height: 100vh;
        }
        .animate-spin {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .glass-effect {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body class="text-white p-4 md:p-6">
    <div class="max-w-7xl mx-auto">
        <div class="flex flex-col md:flex-row justify-between items-start md:items-center gap-4 mb-8">
            <div>
                <h1 class="text-3xl md:text-4xl font-bold bg-gradient-to-r from-yellow-400 to-orange-500 bg-clip-text text-transparent">
                    üê± Bot Trading Multi-Crypto Pro
                </h1>
                <p class="text-gray-400 mt-2">Trading r√©el BSC ‚Ä¢ Prix temps r√©el ‚Ä¢ Trading automatique 24/7 ‚Ä¢ 3 Conditions pour acheter ‚úÖ</p>
            </div>
            
            <div class="flex gap-3">
                <button onclick="openDCASwap()" class="flex items-center gap-2 px-4 py-3 bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 rounded-lg font-semibold transition-all">
                    <span>üîÑ</span>
                    DCA/Swap
                    <span>‚Üó</span>
                </button>
                
                <button onclick="connectWallet()" id="connectBtn" class="flex items-center gap-2 px-6 py-3 rounded-lg font-semibold transition-all bg-gradient-to-r from-yellow-400 to-orange-500 hover:from-yellow-500 hover:to-orange-600">
                    <span>üëõ</span>
                    <span id="walletText">Connecter MetaMask</span>
                </button>
            </div>
        </div>

        <!-- Section Conditions de Trading -->
        <div class="glass-effect rounded-xl p-6 mb-6 border-2 border-blue-500">
            <h3 class="text-xl font-bold mb-4 flex items-center gap-2">
                <span>üéØ</span>
                Conditions de Trading (3 requis pour ACHAT)
            </h3>
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <!-- Condition 1: RSI -->
                <div class="glass-effect border-2 border-slate-600 rounded-lg p-4" id="condition-rsi">
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-bold">üìä RSI Oversold</span>
                        <span class="text-2xl" id="condition-rsi-icon">‚ö™</span>
                    </div>
                    <p class="text-xs text-gray-400">RSI &lt; 40 (survente)</p>
                    <p class="text-sm mt-2">Valeur: <span id="rsi-display" class="font-bold">--</span></p>
                </div>

                <!-- Condition 2: MACD -->
                <div class="glass-effect border-2 border-slate-600 rounded-lg p-4" id="condition-macd">
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-bold">üìà MACD Positif</span>
                        <span class="text-2xl" id="condition-macd-icon">‚ö™</span>
                    </div>
                    <p class="text-xs text-gray-400">MACD histogram &gt; 0</p>
                    <p class="text-sm mt-2">Valeur: <span id="macd-display" class="font-bold">--</span></p>
                </div>

                <!-- Condition 3: Prix vs EMA -->
                <div class="glass-effect border-2 border-slate-600 rounded-lg p-4" id="condition-ema">
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-bold">üíπ Prix au-dessus EMA</span>
                        <span class="text-2xl" id="condition-ema-icon">‚ö™</span>
                    </div>
                    <p class="text-xs text-gray-400">Prix &gt; EMA20</p>
                    <p class="text-sm mt-2">EMA20: <span id="ema-display" class="font-bold">--</span></p>
                </div>
            </div>

            <div class="mt-4 p-4 bg-green-500/20 border border-green-500 rounded-lg">
                <p class="text-center font-bold text-lg">
                    <span class="text-green-400" id="conditions-count">0/3</span> conditions valid√©es
                </p>
                <div class="w-full h-3 bg-slate-700 rounded-full mt-2 overflow-hidden">
                    <div class="h-full bg-gradient-to-r from-green-400 to-blue-500 transition-all duration-300" id="conditions-progress" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <div id="subscriptionSection" class="glass-effect rounded-xl p-6 mb-6 border-2 border-purple-500 hidden">
            <h3 class="text-xl font-bold mb-4 flex items-center gap-2">
                <span>üíé</span>
                Abonnement Bot Trading Pro
            </h3>
            
            <div id="freeTrialInfo" class="bg-green-500/20 border border-green-500 rounded-lg p-4 mb-4">
                <p class="text-green-300 font-bold mb-2">üéÅ OFFRE DE LANCEMENT</p>
                <p class="text-sm text-green-200">
                    ‚úÖ 2 jours GRATUITS pour tester le bot<br>
                    ‚úÖ Toutes les fonctionnalit√©s incluses<br>
                    ‚úÖ Trading r√©el + Simulation<br>
                    <span id="trialDaysRemaining" class="font-bold text-green-400"></span>
                </p>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                <div class="glass-effect border-2 border-slate-600 rounded-lg p-4 hover:border-purple-400 transition-all cursor-pointer" onclick="selectPlan(1, 1)">
                    <div class="text-center">
                        <p class="text-2xl font-bold text-purple-400">1 USDT</p>
                        <p class="text-sm text-gray-400 mt-1">1 jour</p>
                        <p class="text-xs text-gray-500 mt-2">Essai simple</p>
                    </div>
                </div>

                <div class="glass-effect border-2 border-purple-500 rounded-lg p-4 hover:border-purple-400 transition-all cursor-pointer relative" onclick="selectPlan(7, 6)">
                    <div class="absolute -top-3 -right-3 bg-yellow-400 text-black text-xs font-bold px-2 py-1 rounded-full">
                        -14%
                    </div>
                    <div class="text-center">
                        <p class="text-2xl font-bold text-purple-400">6 USDT</p>
                        <p class="text-sm text-gray-400 mt-1">7 jours</p>
                        <p class="text-xs text-gray-500 mt-2">0.86 USDT/jour</p>
                        <p class="text-xs text-green-400 mt-1">‚≠ê Populaire</p>
                    </div>
                </div>

                <div class="glass-effect border-2 border-yellow-500 rounded-lg p-4 hover:border-purple-400 transition-all cursor-pointer relative" onclick="selectPlan(30, 20)">
                    <div class="absolute -top-3 -right-3 bg-yellow-400 text-black text-xs font-bold px-2 py-1 rounded-full">
                        -33%
                    </div>
                    <div class="text-center">
                        <p class="text-2xl font-bold text-yellow-400">20 USDT</p>
                        <p class="text-sm text-gray-400 mt-1">30 jours</p>
                        <p class="text-xs text-gray-500 mt-2">0.67 USDT/jour</p>
                        <p class="text-xs text-yellow-400 mt-1">üèÜ Meilleure valeur</p>
                    </div>
                </div>
            </div>

            <div id="selectedPlanInfo" class="bg-blue-500/20 border border-blue-500 rounded-lg p-4 mb-4 hidden">
                <p class="text-blue-300 font-bold mb-2">üìã Forfait s√©lectionn√©</p>
                <p class="text-sm text-blue-200">
                    <span id="planDuration"></span> jours pour <span id="planPrice"></span> USDT
                </p>
            </div>

            <button onclick="processPayment()" id="paymentBtn" class="w-full flex items-center justify-center gap-2 px-6 py-4 bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 rounded-lg font-bold text-lg transition-all disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                <span>üí≥</span>
                <span id="paymentBtnText">S√©lectionnez un forfait</span>
            </button>

            <div class="mt-4 p-3 glass-effect rounded-lg">
                <p class="text-xs text-gray-400 text-center">
                    üîí Paiement s√©curis√© via BSC ‚Ä¢ Pas de donn√©es bancaires requises
                </p>
            </div>
        </div>

        <div id="cryptoSelector" class="glass-effect rounded-xl p-6 mb-6 hidden">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold">S√©lectionner la Crypto</h3>
                <button onclick="fetchCryptoList()" id="refreshBtn" class="flex items-center gap-2 px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg transition-all">
                    <span id="refreshIcon">üîÑ</span>
                    <span id="refreshText">Actualiser</span>
                </button>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label class="block text-sm text-gray-400 mb-2">Cryptomonnaie <span id="cryptoCount"></span></label>
                    <select id="cryptoSelect" onchange="changeCrypto()" class="w-full glass-effect rounded-lg px-4 py-3 focus:outline-none focus:border-yellow-400 text-lg font-semibold cursor-pointer">
                        <option>Chargement...</option>
                    </select>
                    <p class="text-xs text-gray-400 mt-2">üíé = Trading r√©el OK ‚Ä¢ üéÆ = Simulation</p>
                </div>
                
                <div>
                    <label class="block text-sm text-gray-400 mb-2">Mode de Trading</label>
                    <select id="tradingMode" onchange="changeTradingMode()" class="w-full glass-effect rounded-lg px-4 py-3 focus:outline-none focus:border-yellow-400 text-lg font-semibold cursor-pointer">
                        <option value="simulation">üéÆ Simulation</option>
                        <option value="real">üíé R√©el (PancakeSwap)</option>
                    </select>
                    <p class="text-xs text-gray-400 mt-2" id="modeInfo">‚ö†Ô∏è Activez uniquement si vous comprenez les risques</p>
                </div>
            </div>
        </div>

        <!-- ‚úÖ SECTION CL√â PRIV√âE AM√âLIOR√âE -->
        <div id="privateKeySection" class="glass-effect rounded-xl p-6 mb-6 border-2 border-yellow-500 hidden">
            <h3 class="text-2xl font-bold mb-4 flex items-center gap-2">
                <span>üîê</span>
                Trading Automatique 24/7 Sans Confirmation
            </h3>
            
            <div class="bg-yellow-900/30 border-2 border-yellow-500 rounded-lg p-4 mb-4">
                <p class="text-yellow-300 font-bold mb-3 text-lg">‚ö° MODE AUTOMATIQUE ACTIV√â</p>
                <p class="text-yellow-200 text-sm mb-2">
                    En entrant votre cl√© priv√©e, le bot pourra trader automatiquement 24/7 SANS confirmation MetaMask.
                </p>
                <p class="text-green-300 font-bold text-sm">
                    ‚úÖ Id√©al pour laisser le bot tourner pendant que vous dormez ou travaillez
                </p>
            </div>

            <div class="bg-red-900/30 border-2 border-red-500 rounded-lg p-4 mb-4">
                <p class="text-red-300 font-bold mb-2">‚ö†Ô∏è AVERTISSEMENTS CRITIQUES</p>
                <ul class="text-sm text-red-200 space-y-1">
                    <li>‚Ä¢ <strong>Utilisez UNIQUEMENT un wallet d√©di√©</strong> avec petit capital (10-50 USDT)</li>
                    <li>‚Ä¢ Votre cl√© priv√©e ne sera <strong>JAMAIS sauvegard√©e</strong></li>
                    <li>‚Ä¢ Stock√©e uniquement en <strong>m√©moire pendant la session</strong></li>
                    <li>‚Ä¢ <strong>Effac√©e automatiquement</strong> √† la fermeture de l'onglet</li>
                    <li>‚Ä¢ <strong>Ne JAMAIS</strong> utiliser votre wallet principal</li>
                    <li>‚Ä¢ Laissez vide pour utiliser MetaMask (manuel avec confirmation)</li>
                </ul>
            </div>

            <div class="space-y-4">
                <div>
                    <label class="block text-lg font-bold text-gray-300 mb-3">
                        üîë Cl√© Priv√©e (Optionnel - Pour Trading Automatique 24/7)
                    </label>
                    <input 
                        type="password" 
                        id="privateKeyInput" 
                        placeholder="0x... ou laisser vide pour MetaMask" 
                        class="w-full glass-effect rounded-lg px-4 py-4 focus:outline-none focus:border-yellow-400 text-lg border-2 border-gray-600 focus:border-yellow-400"
                    >
                    <div class="mt-3 p-3 bg-blue-500/20 border border-blue-500 rounded-lg">
                        <p class="text-sm text-blue-200">
                            <span class="text-yellow-400 font-bold">‚ö° VIDE</span> = Mode manuel (MetaMask avec confirmation)<br>
                            <span class="text-green-400 font-bold">‚ö° REMPLI</span> = Mode automatique 24/7 (sans confirmation)
                        </p>
                    </div>
                </div>
                
                <div class="flex gap-3">
                    <button onclick="togglePrivateKeyVisibility()" class="flex-1 px-4 py-3 bg-blue-600 hover:bg-blue-700 rounded-lg font-semibold transition-all">
                        üëÅÔ∏è Afficher/Masquer la cl√©
                    </button>
                    <button onclick="clearPrivateKey()" class="flex-1 px-4 py-3 bg-red-600 hover:bg-red-700 rounded-lg font-semibold transition-all">
                        üóëÔ∏è Effacer la cl√©
                    </button>
                </div>
            </div>

            <div class="mt-4 p-4 bg-purple-500/20 border border-purple-500 rounded-lg">
                <p class="text-purple-300 font-bold mb-2">üí° COMMENT OBTENIR VOTRE CL√â PRIV√âE ?</p>
                <ol class="text-sm text-purple-200 space-y-2">
                    <li>1. Ouvrez MetaMask</li>
                    <li>2. Cliquez sur les 3 points ‚Üí D√©tails du compte</li>
                    <li>3. Cliquez sur "Exporter la cl√© priv√©e"</li>
                    <li>4. Entrez votre mot de passe MetaMask</li>
                    <li>5. Copiez la cl√© (commence par 0x...)</li>
                    <li>6. Collez-la dans le champ ci-dessus</li>
                </ol>
            </div>
        </div>

        <div id="capitalSection" class="glass-effect rounded-xl p-6 mb-6 border-2 border-green-500 hidden">
            <h3 class="text-xl font-bold mb-4 flex items-center gap-2">
                <span>üéØ</span>
                Capital de trading en USDT
            </h3>
            <p class="text-gray-300 mb-4">
                Montant en USDT pour le trading automatique
                <br />
                <span class="text-sm text-gray-400">Solde disponible: <span id="availableBalance" class="font-bold text-green-400">0</span> USDT</span>
            </p>
            <div class="flex gap-4 mb-3">
                <input type="number" id="capitalInput" placeholder="Ex: 50" step="10" class="flex-1 glass-effect rounded-lg px-4 py-3 focus:outline-none focus:border-green-400 border-2 border-gray-600">
                <button onclick="setCapital()" class="px-8 py-3 bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 rounded-lg font-semibold transition-all">
                    ‚úÖ Valider
                </button>
            </div>
            <div class="flex gap-2">
                <button onclick="setMaxCapital()" class="flex-1 px-4 py-2 glass-effect hover:bg-slate-700 rounded-lg text-sm transition-all">
                    üíØ Utiliser 100%
                </button>
                <button onclick="setHalfCapital()" class="flex-1 px-4 py-2 glass-effect hover:bg-slate-700 rounded-lg text-sm transition-all">
                    ‚ûó Utiliser 50%
                </button>
                <button onclick="syncWalletBalance()" class="flex-1 px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm transition-all">
                    üîÑ Actualiser
                </button>
            </div>
        </div>

        <div id="statsCards" class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8 hidden">
            <div class="glass-effect rounded-xl p-4">
                <p class="text-gray-400 text-xs">Capital</p>
                <p class="text-xl font-bold mt-1 text-green-400">$<span id="capitalDisplay">0</span></p>
            </div>
            
            <div class="glass-effect rounded-xl p-4">
                <p class="text-gray-400 text-xs">Prix <span id="cryptoName">BTC</span></p>
                <p class="text-xl font-bold mt-1">$<span id="currentPrice">...</span></p>
            </div>
            
            <div class="glass-effect rounded-xl p-4">
                <p class="text-gray-400 text-xs">Profit</p>
                <p class="text-xl font-bold mt-1 text-green-400">$<span id="profitDisplay">0.00</span></p>
            </div>
            
            <div class="glass-effect rounded-xl p-4">
                <p class="text-gray-400 text-xs">Mode</p>
                <p class="text-xl font-bold mt-1" id="modeDisplay">üéÆ SIM</p>
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div class="lg:col-span-2 space-y-6">
                <div class="glass-effect rounded-xl p-6">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-bold">üìà Graphique de Trading</h2>
                        <div class="text-sm text-gray-400">
                            <span id="chartCrypto">BTC</span>/USDT
                        </div>
                    </div>
                    <div class="h-64">
                        <canvas id="tradingChart"></canvas>
                    </div>
                </div>

                <div class="glass-effect rounded-xl p-6">
                    <h2 class="text-2xl font-bold mb-4">Strat√©gies</h2>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4" id="strategiesGrid"></div>
                </div>

                <div class="glass-effect rounded-xl p-6">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-bold">Historique des Trades</h2>
                        <button onclick="toggleBot()" id="toggleBotBtn" disabled class="flex items-center gap-2 px-6 py-2 rounded-lg font-semibold transition-all bg-gray-600 cursor-not-allowed">
                            <span id="botIcon">‚ñ∂Ô∏è</span>
                            <span id="botText">D√©marrer</span>
                        </button>
                    </div>
                    <div id="tradesContainer">
                        <div class="text-center py-8 text-gray-400">
                            <span class="text-4xl">‚ö†Ô∏è</span>
                            <p>Aucun trade</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="glass-effect rounded-xl p-6">
                <h2 class="text-2xl font-bold mb-4">Param√®tres</h2>
                
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm text-gray-400 mb-2">% par trade</label>
                        <input type="number" id="tradePercent" value="10" min="1" max="100" onchange="updateTradeAmount()" class="w-full glass-effect rounded-lg px-4 py-2 focus:outline-none focus:border-yellow-400">
                        <p class="text-xs text-gray-400 mt-1">Montant: $<span id="tradeAmount">0</span></p>
                    </div>
                    
                    <div>
                        <label class="block text-sm text-gray-400 mb-2">Slippage (%)</label>
                        <input type="number" id="slippage" value="1" step="0.1" class="w-full glass-effect rounded-lg px-4 py-2 focus:outline-none focus:border-yellow-400">
                        <p class="text-xs text-gray-400 mt-1">‚ö†Ô∏è Recommand√©: 1-2% pour tokens volatils</p>
                    </div>
                </div>

                <div class="mt-6 p-4 bg-green-400/10 border border-green-400/30 rounded-lg">
                    <div class="flex gap-2">
                        <span class="text-green-400">üí∞</span>
                        <div class="text-sm text-gray-300">
                            <p class="font-semibold text-green-400">Soldes</p>
                            <p>BNB: <span id="bnbBalance">0</span></p>
                            <p>USDT: $<span id="usdtBalance">0</span></p>
                        </div>
                    </div>
                </div>

                <div class="mt-4 p-4 bg-blue-400/10 border border-blue-400/30 rounded-lg">
                    <div class="flex gap-2">
                        <span class="text-blue-400">üìä</span>
                        <div class="text-sm text-gray-300">
                            <p class="font-semibold text-blue-400">Statut</p>
                            <p>Wallet: <span id="walletStatus">üî¥ Non connect√©</span></p>
                            <p>Mode: <span id="tradingTypeStatus">üü° ...</span></p>
                            <p>Position: <span id="positionStatus">‚ö™ Aucune</span></p>
                            <p>Binance: <span id="apiStatus">üü° ...</span></p>
                            <p>Ethers: <span id="ethersStatus">üü° ...</span></p>
                        </div>
                    </div>
                </div>

                <div class="mt-4 p-4 bg-red-400/10 border border-red-400/30 rounded-lg">
                    <div class="flex gap-2">
                        <span class="text-red-400">‚ö†Ô∏è</span>
                        <div class="text-xs text-gray-300">
                            <p class="font-semibold text-red-400">ATTENTION</p>
                            <p>‚Ä¢ Risque de perte totale</p>
                            <p>‚Ä¢ Frais gas + slippage</p>
                            <p>‚Ä¢ Minimum 0.01 BNB pour gas</p>
                            <p>‚Ä¢ Commencez petit (10-50$)</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const PANCAKE_ROUTER = '0x10ED43C718714eb63d5aA57B78B54704E256024E';
        const USDT_CONTRACT = '0x55d398326f99059fF775485246999027B3197955';
        const BSC_RPC = 'https://bsc-dataseed1.binance.org';
        
        const OWNER_WALLET = '0x5959f13ad996ab184780a778cf6d594786f44250';
        const FREE_WALLET = '0xb44dd82c004a767d23b890f788fd6f9b13fcf6a4';
        const FREE_TRIAL_DAYS = 2;

        let state = {
            account: null, 
            isConnected: false, 
            balanceBNB: '0', 
            balanceUSDT: '0',
            selectedCrypto: 'BTCUSDT', 
            cryptoList: [], 
            currentPrice: null, 
            priceHistory: [],
            tradingCapital: 0, 
            capitalSet: false, 
            tradingMode: 'simulation',
            botRunning: false, 
            trades: [], 
            portfolio: { profit: 0, profitPercent: 0 },
            indicators: { rsi: 50, macd: { histogram: 0 }, ema20: 0, ema50: 0 },
            selectedStrategy: 'scalping', 
            provider: null,
            privateKey: null,
            wallet: null,
            autoMode: false,
            currentPosition: null,
            lastBuyPrice: 0,
            positionAmount: 0,
            lastSellTime: 0,
            chartData: { labels: [], prices: [], buyPoints: [], sellPoints: [] },
            subscription: {
                isActive: false,
                expiryDate: null,
                firstAccessDate: null,
                selectedPlan: null
            },
            buyConditions: {
                rsi: false,
                macd: false,
                ema: false
            }
        };

        let ws = null, botInterval = null, lastTradeTime = 0;
        let tradingChart = null;

        const POST_SELL_COOLDOWN = 120000;

        const TOKEN_ADDRESSES = {
            'BTCUSDT': '0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c',
            'ETHUSDT': '0x2170Ed0880ac9A755fd29B2688956BD959F933F8',
            'BNBUSDT': '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',
            'XRPUSDT': '0x1D2F0da169ceB9fC7B3144628dB4',
            'ADAUSDT': '0x3EE2200Efb3400fAbB9AacF31297cBdD1d435D47',
            'DOGEUSDT': '0xbA2aE424d960c26247Dd6c32edC70B295c744C43',
            'SOLUSDT': '0x570A5D26f7765Ecb712C0924E4De545B89fD43dF',
            'TRXUSDT': '0xCE7de646e7208a4Ef112cb6ed5038FA6cC6b12e3',
            'DOTUSDT': '0x7083609fCE4d1d8Dc0C979AAb8c869Ea2C873402',
            'MATICUSDT': '0xCC42724C6683B7E57334c4E856f4c9965ED682bD',
            'LINKUSDT': '0xF8A0BF9cF54Bb92F17374d9e9A321E6a111a51bD',
            'AVAXUSDT': '0x1CE0c2827e2eF14D5C4f29a091d735A204794041',
            'UNIUSDT': '0xBf5140A22578168FD562DCcF235E5D43A02ce9B1',
            'SHIBUSDT': '0x2859e4544C4bB03966803b044A93563Bd2D0DD4D',
            'LTCUSDT': '0x4338665CBB7B2485A8855A139b75D5e34AB0DB94',
            'BCHUSDT': '0x8fF795a6F4D97E7887C79beA79aba5cc76444aDf',
            'XLMUSDT': '0x43C934A845205F0b514417d757d7235B8f53f1B9',
            'ATOMUSDT': '0x0Eb3a705fc54725037CC9e008bDede697f62F335',
            'ETCUSDT': '0x3d6545b08693daE087E957cb1180ee38B9e3c25E',
            'FILUSDT': '0x0D8Ce2A99Bb6e3B7Db580eD848240e4a0F9aE153',
            'NEARUSDT': '0x1Fa4a73a3F0133f0025378af00236f3aBDEE5D63',
            'AAVEUSDT': '0xfb6115445Bff7b52FeB98650C87f44907E58f802',
            'VETUSDT': '0x6FDcdfef7c496407cCb0cEC90f9C5Aaa1Cc8D888',
            'ALGOUSDT': '0xAC51066d7bEC65Dc4589368da368b212745d63E8',
            'ICPUSDT': '0xa9c41A46a6B3531d28d5c32F6633dd2fF05dFB90',
            'APTUSDT': '0x6970460aabF80C5BE983C6b74e5D06dEDCA95D4A',
            'OPUSDT': '0xd3c325848d7c6E29b574Cb0789998b2ff901f17E',
            'ARBUSDT': '0x912CE59144191C1204E64559FE8253a0e49E6548',
            'FETUSDT': '0x031b41e504677879370e9DBcF937283A8691Fa7f',
            'PEPEUSDT': '0x25d887Ce7a35172C62FeBFD67a1856F20FaEbB00',
            'CAKEUSDT': '0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82'
        };

        const strategies = {
            scalping: { 
                name: 'Scalping', 
                description: 'Rapide RSI+MACD', 
                minTradeInterval: 180000,
                rsiBuyThreshold: 40,
                rsiBuyStrong: 30,
                rsiSellThreshold: 60,
                rsiSellStrong: 70,
                takeProfit: 2.2,
                stopLoss: -1.8
            },
            swing: { 
                name: 'Swing', 
                description: 'Positions EMA', 
                minTradeInterval: 900000,
                rsiBuyThreshold: 35,
                rsiBuyStrong: 25,
                rsiSellThreshold: 70,
                rsiSellStrong: 75,
                takeProfit: 2.2,
                stopLoss: -1.8
            },
            arbitrage: { 
                name: 'Arbitrage', 
                description: 'Diff prix', 
                minTradeInterval: 60000,
                rsiBuyThreshold: 45,
                rsiBuyStrong: 35,
                rsiSellThreshold: 55,
                rsiSellStrong: 65,
                takeProfit: 2.2,
                stopLoss: -1.8
            }
        };

        window.addEventListener('DOMContentLoaded', () => {
            console.log('üöÄ Bot charg√© - CONVERSION USDT CORRIG√âE');
            
            if (typeof ethers !== 'undefined') {
                document.getElementById('ethersStatus').innerHTML = 'üü¢ v' + ethers.version;
                console.log('‚úÖ Ethers.js version:', ethers.version);
            } else {
                document.getElementById('ethersStatus').innerHTML = 'üî¥ Erreur';
                console.error('‚ùå Ethers.js non charg√©');
            }
            
            initChart();
            renderStrategies();
            fetchCryptoList();
        });

        function clearPrivateKey() {
            document.getElementById('privateKeyInput').value = '';
            state.privateKey = null;
            state.wallet = null;
            state.autoMode = false;
            console.log('üóëÔ∏è Cl√© priv√©e effac√©e');
            alert('‚úÖ Cl√© priv√©e effac√©e de la m√©moire');
        }

        function initChart() {
            const ctx = document.getElementById('tradingChart').getContext('2d');
            tradingChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Prix',
                        data: [],
                        borderColor: 'rgb(59, 130, 246)',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        tension: 0.4,
                        pointRadius: 0,
                        borderWidth: 2
                    }, {
                        label: 'Achats',
                        data: [],
                        backgroundColor: 'rgb(34, 197, 94)',
                        pointRadius: 8,
                        pointStyle: 'triangle',
                        showLine: false,
                        pointRotation: 0
                    }, {
                        label: 'Ventes',
                        data: [],
                        backgroundColor: 'rgb(239, 68, 68)',
                        pointRadius: 8,
                        pointStyle: 'triangle',
                        showLine: false,
                        pointRotation: 180
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            labels: { color: 'rgb(156, 163, 175)' }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            grid: { color: 'rgba(75, 85, 99, 0.3)' },
                            ticks: { color: 'rgb(156, 163, 175)', maxTicksLimit: 10 }
                        },
                        y: {
                            display: true,
                            grid: { color: 'rgba(75, 85, 99, 0.3)' },
                            ticks: { color: 'rgb(156, 163, 175)' }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
        }

        function updateChart() {
            if (!tradingChart || state.priceHistory.length === 0) return;
            
            const maxPoints = 100;
            const prices = state.priceHistory.slice(-maxPoints);
            const labels = prices.map((_, i) => {
                const date = new Date(Date.now() - (maxPoints - i) * 5000);
                return date.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
            });
            
            const buyPoints = new Array(prices.length).fill(null);
            const sellPoints = new Array(prices.length).fill(null);
            
            state.trades.slice(0, 20).forEach(trade => {
                const tradePrice = parseFloat(trade.entryPrice);
                const closestIndex = prices.length - Math.floor(Math.random() * 10) - 1;
                if (closestIndex >= 0 && closestIndex < prices.length) {
                    if (trade.type === 'BUY') {
                        buyPoints[closestIndex] = tradePrice;
                    } else {
                        sellPoints[closestIndex] = tradePrice;
                    }
                }
            });
            
            tradingChart.data.labels = labels;
            tradingChart.data.datasets[0].data = prices;
            tradingChart.data.datasets[1].data = buyPoints;
            tradingChart.data.datasets[2].data = sellPoints;
            tradingChart.update('none');
        }

        function renderStrategies() {
            document.getElementById('strategiesGrid').innerHTML = Object.entries(strategies).map(([key, s]) => {
                const intervalMinutes = s.minTradeInterval / 60000;
                const intervalDisplay = intervalMinutes >= 1 
                    ? `${intervalMinutes} min` 
                    : `${s.minTradeInterval / 1000}s`;
                
                return `
                <div onclick="selectStrategy('${key}')" class="p-4 rounded-lg border-2 ${state.selectedStrategy === key ? 'border-yellow-400 bg-yellow-400/10' : 'border-slate-600 glass-effect'} cursor-pointer hover:border-yellow-400/50 transition-all">
                    <h3 class="font-bold mb-2">${s.name}</h3>
                    <p class="text-gray-400 text-sm mb-2">${s.description}</p>
                    <div class="text-xs text-gray-500 space-y-0.5">
                        <p>üìä Achat: RSI &lt; ${s.rsiBuyThreshold}</p>
                        <p>üìà Vente: RSI &gt; ${s.rsiSellThreshold}</p>
                        <p>üéØ TP: +${s.takeProfit}% | SL: ${s.stopLoss}%</p>
                        <p>‚è±Ô∏è Cooldown: ${intervalDisplay}</p>
                    </div>
                </div>
            `}).join('');
        }

        function selectStrategy(key) {
            const oldStrategy = state.selectedStrategy;
            state.selectedStrategy = key;
            renderStrategies();
            
            const newStrategy = strategies[key];
            const intervalDisplay = newStrategy.minTradeInterval >= 60000 
                ? `${newStrategy.minTradeInterval / 60000} min` 
                : `${newStrategy.minTradeInterval / 1000}s`;
            
            console.log(`\n${'üìã'.repeat(35)}`);
            console.log(`üìã CHANGEMENT DE STRAT√âGIE`);
            console.log(`${'üìã'.repeat(35)}`);
            console.log(`‚è∞ ${new Date().toLocaleString('fr-FR')}`);
            console.log(`‚ùå Ancienne: ${strategies[oldStrategy].name}`);
            console.log(`‚úÖ Nouvelle: ${newStrategy.name}`);
            console.log(`\nüìä PARAM√àTRES:`);
            console.log(`   ‚Ä¢ Achat: RSI < ${newStrategy.rsiBuyThreshold} (fort: < ${newStrategy.rsiBuyStrong})`);
            console.log(`   ‚Ä¢ Vente: RSI > ${newStrategy.rsiSellThreshold} (fort: > ${newStrategy.rsiSellStrong})`);
            console.log(`   ‚Ä¢ Take Profit: +${newStrategy.takeProfit}%`);
            console.log(`   ‚Ä¢ Stop Loss: ${newStrategy.stopLoss}%`);
            console.log(`   ‚Ä¢ Cooldown: ${intervalDisplay} entre chaque trade`);
            console.log(`   ‚Ä¢ ‚úÖ 3 CONDITIONS REQUISES POUR ACHAT`);
            console.log(`${'='.repeat(70)}\n`);
        }

        function openDCASwap() {
            window.open('https://reboot-20.vercel.app/', '_blank');
        }

        function togglePrivateKeyVisibility() {
            const input = document.getElementById('privateKeyInput');
            input.type = input.type === 'password' ? 'text' : 'password';
        }

        async function connectWallet() {
            if (!window.ethereum) {
                alert('‚ùå MetaMask non install√©');
                return;
            }

            try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                
                if (chainId !== '0x38') {
                    await window.ethereum.request({
                        method: 'wallet_addEthereumChain',
                        params: [{
                            chainId: '0x38',
                            chainName: 'BNB Smart Chain',
                            nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 },
                            rpcUrls: [BSC_RPC],
                            blockExplorerUrls: ['https://bscscan.com']
                        }]
                    });
                }
                
                state.account = accounts[0];
                state.provider = new ethers.providers.Web3Provider(window.ethereum);
                
                const bnbBalance = await state.provider.getBalance(state.account);
                state.balanceBNB = ethers.utils.formatEther(bnbBalance);
                
                const usdtBalance = await getTokenBalance(USDT_CONTRACT, state.account);
                state.balanceUSDT = ethers.utils.formatUnits(usdtBalance, 18);
                
                state.isConnected = true;
                
                console.log('‚úÖ Wallet:', state.account);
                console.log('üí∞ BNB:', state.balanceBNB);
                console.log('üíµ USDT:', state.balanceUSDT);
                
                const usdtAmount = parseFloat(state.balanceUSDT);
                if (usdtAmount > 0) {
                    document.getElementById('capitalInput').value = Math.floor(usdtAmount);
                    console.log('üí° Capital sugg√©r√©:', Math.floor(usdtAmount), 'USDT');
                }
                
                updateUI();
                await checkSubscription();
                fetchCryptoList();
            } catch (error) {
                console.error('‚ùå Erreur connexion:', error);
                alert('Erreur connexion wallet: ' + error.message);
            }
        }

        function checkSubscription() {
            const walletLower = state.account.toLowerCase();
            
            if (walletLower === FREE_WALLET.toLowerCase()) {
                state.subscription.isActive = true;
                state.subscription.expiryDate = new Date(2099, 11, 31);
                console.log('üëë Acc√®s VIP gratuit activ√©');
                
                document.getElementById('subscriptionSection').classList.remove('hidden');
                document.getElementById('freeTrialInfo').innerHTML = `
                    <p class="text-yellow-300 font-bold mb-2">üëë ACC√àS VIP GRATUIT</p>
                    <p class="text-sm text-yellow-200">
                        ‚úÖ Acc√®s illimit√© √† vie<br>
                        ‚úÖ Toutes les fonctionnalit√©s incluses<br>
                        ‚úÖ Aucun paiement requis
                    </p>
                `;
                document.getElementById('freeTrialInfo').className = 'bg-yellow-500/20 border border-yellow-500 rounded-lg p-4 mb-4';
                
                document.querySelectorAll('#subscriptionSection > div:not(#freeTrialInfo)').forEach(el => {
                    if (el.id !== 'freeTrialInfo') el.style.display = 'none';
                });
                
                setTimeout(() => {
                    document.getElementById('subscriptionSection').classList.add('hidden');
                    document.getElementById('cryptoSelector').classList.remove('hidden');
                }, 5000);
                
                return true;
            }
            
            const savedSub = localStorage.getItem(`subscription_${walletLower}`);
            
            if (savedSub) {
                const subData = JSON.parse(savedSub);
                const expiryDate = new Date(subData.expiryDate);
                const now = new Date();
                
                if (now < expiryDate) {
                    state.subscription.isActive = true;
                    state.subscription.expiryDate = expiryDate;
                    state.subscription.firstAccessDate = new Date(subData.firstAccessDate);
                    
                    const daysLeft = Math.ceil((expiryDate - now) / (1000 * 60 * 60 * 24));
                    console.log(`‚úÖ Abonnement actif - ${daysLeft} jours restants`);
                    
                    document.getElementById('subscriptionSection').classList.remove('hidden');
                    document.getElementById('freeTrialInfo').innerHTML = `
                        <p class="text-green-300 font-bold mb-2">‚úÖ ABONNEMENT ACTIF</p>
                        <p class="text-sm text-green-200">
                            ‚è∞ ${daysLeft} jour${daysLeft > 1 ? 's' : ''} restant${daysLeft > 1 ? 's' : ''}<br>
                            üìÖ Expire le: ${expiryDate.toLocaleDateString('fr-FR')}<br>
                            ‚úÖ Acc√®s complet au bot
                        </p>
                    `;
                    document.getElementById('freeTrialInfo').className = 'bg-green-500/20 border border-green-500 rounded-lg p-4 mb-4';
                    
                    document.querySelectorAll('#subscriptionSection > div:not(#freeTrialInfo)').forEach(el => {
                        if (el.id !== 'freeTrialInfo') el.style.display = 'none';
                    });
                    
                    setTimeout(() => {
                        document.getElementById('subscriptionSection').classList.add('hidden');
                        document.getElementById('cryptoSelector').classList.remove('hidden');
                    }, 5000);
                    
                    return true;
                } else {
                    console.log('‚ö†Ô∏è Abonnement expir√©');
                }
            }
            
            const firstAccess = localStorage.getItem(`first_access_${walletLower}`);
            
            if (!firstAccess) {
                const now = new Date();
                const expiryDate = new Date(now.getTime() + FREE_TRIAL_DAYS * 24 * 60 * 60 * 1000);
                
                localStorage.setItem(`first_access_${walletLower}`, now.toISOString());
                localStorage.setItem(`subscription_${walletLower}`, JSON.stringify({
                    expiryDate: expiryDate.toISOString(),
                    firstAccessDate: now.toISOString(),
                    isTrial: true
                }));
                
                state.subscription.isActive = true;
                state.subscription.expiryDate = expiryDate;
                state.subscription.firstAccessDate = now;
                
                console.log(`üéÅ P√©riode d'essai gratuite activ√©e - ${FREE_TRIAL_DAYS} jours`);
                
                document.getElementById('subscriptionSection').classList.remove('hidden');
                document.getElementById('freeTrialInfo').innerHTML = `
                    <p class="text-green-300 font-bold mb-2">üéÅ BIENVENUE ! ESSAI GRATUIT ACTIV√â</p>
                    <p class="text-sm text-green-200">
                        ‚úÖ ${FREE_TRIAL_DAYS} jours GRATUITS pour tester le bot<br>
                        ‚úÖ Toutes les fonctionnalit√©s incluses<br>
                        ‚úÖ Trading r√©el + Simulation<br>
                        <span class="font-bold text-green-400">‚è∞ Expire le: ${expiryDate.toLocaleDateString('fr-FR')} √† ${expiryDate.toLocaleTimeString('fr-FR', {hour: '2-digit', minute: '2-digit'})}</span>
                    </p>
                `;
                document.getElementById('freeTrialInfo').className = 'bg-green-500/20 border border-green-500 rounded-lg p-4 mb-4';
                
                document.querySelectorAll('#subscriptionSection > div').forEach(el => {
                    el.style.display = '';
                });
                
                setTimeout(() => {
                    document.getElementById('subscriptionSection').classList.add('hidden');
                    document.getElementById('cryptoSelector').classList.remove('hidden');
                }, 10000);
                
                return true;
            } else {
                const firstAccessDate = new Date(firstAccess);
                const now = new Date();
                const trialExpiryDate = new Date(firstAccessDate.getTime() + FREE_TRIAL_DAYS * 24 * 60 * 60 * 1000);
                
                if (now >= trialExpiryDate) {
                    console.log('‚ùå P√©riode d\'essai expir√©e - Paiement requis');
                    
                    document.getElementById('subscriptionSection').classList.remove('hidden');
                    document.getElementById('cryptoSelector').classList.add('hidden');
                    document.getElementById('privateKeySection').classList.add('hidden');
                    document.getElementById('capitalSection').classList.add('hidden');
                    
                    document.getElementById('freeTrialInfo').innerHTML = `
                        <p class="text-red-300 font-bold mb-2">‚è∞ P√âRIODE D'ESSAI EXPIR√âE</p>
                        <p class="text-sm text-red-200">
                            Votre essai gratuit de ${FREE_TRIAL_DAYS} jours est termin√©.<br>
                            üìÖ Expir√© le: ${trialExpiryDate.toLocaleDateString('fr-FR')}<br>
                            üíé Choisissez un forfait ci-dessous pour continuer √† utiliser le bot.
                        </p>
                    `;
                    document.getElementById('freeTrialInfo').className = 'bg-red-500/20 border border-red-500 rounded-lg p-4 mb-4';
                    
                    document.querySelectorAll('#subscriptionSection > div').forEach(el => {
                        el.style.display = '';
                    });
                    
                    return false;
                } else {
                    const daysLeft = Math.ceil((trialExpiryDate - now) / (1000 * 60 * 60 * 24));
                    const hoursLeft = Math.ceil((trialExpiryDate - now) / (1000 * 60 * 60));
                    console.log(`üéÅ Essai gratuit - ${daysLeft} jours restants`);
                    
                    state.subscription.isActive = true;
                    state.subscription.expiryDate = trialExpiryDate;
                    
                    document.getElementById('subscriptionSection').classList.remove('hidden');
                    document.getElementById('freeTrialInfo').innerHTML = `
                        <p class="text-green-300 font-bold mb-2">üéÅ ESSAI GRATUIT EN COURS</p>
                        <p class="text-sm text-green-200">
                            ‚è∞ Il vous reste ${daysLeft > 0 ? daysLeft + ' jour(s)' : hoursLeft + ' heure(s)'}<br>
                            üìÖ Expire le: ${trialExpiryDate.toLocaleDateString('fr-FR')} √† ${trialExpiryDate.toLocaleTimeString('fr-FR', {hour: '2-digit', minute: '2-digit'})}<br>
                            üí° Profitez-en pour tester toutes les fonctionnalit√©s !
                        </p>
                    `;
                    document.getElementById('freeTrialInfo').className = 'bg-green-500/20 border border-green-500 rounded-lg p-4 mb-4';
                    
                    document.querySelectorAll('#subscriptionSection > div').forEach(el => {
                        el.style.display = '';
                    });
                    
                    setTimeout(() => {
                        document.getElementById('subscriptionSection').classList.add('hidden');
                        document.getElementById('cryptoSelector').classList.remove('hidden');
                    }, 8000);
                    
                    return true;
                }
            }
        }

        function selectPlan(days, price) {
            state.subscription.selectedPlan = { days, price };
            
            document.getElementById('selectedPlanInfo').classList.remove('hidden');
            document.getElementById('planDuration').textContent = days;
            document.getElementById('planPrice').textContent = price;
            document.getElementById('paymentBtn').disabled = false;
            document.getElementById('paymentBtnText').textContent = `Payer ${price} USDT pour ${days} jours`;
            
            console.log(`üìã Forfait s√©lectionn√©: ${days} jours pour ${price} USDT`);
        }

        async function processPayment() {
            if (!state.subscription.selectedPlan) {
                alert('‚ùå Veuillez s√©lectionner un forfait');
                return;
            }
            
            const { days, price } = state.subscription.selectedPlan;
            
            const confirm = window.confirm(
                `üí≥ CONFIRMATION DE PAIEMENT\n\n` +
                `Forfait: ${days} jours\n` +
                `Prix: ${price} USDT\n` +
                `Destinataire: ${OWNER_WALLET.slice(0, 8)}...${OWNER_WALLET.slice(-6)}\n\n` +
                `Confirmez-vous ce paiement ?`
            );
            
            if (!confirm) return;
            
            try {
                console.log('üí≥ Traitement du paiement...');
                document.getElementById('paymentBtnText').textContent = 'Traitement en cours...';
                document.getElementById('paymentBtn').disabled = true;
                
                const signer = state.provider.getSigner();
                const usdtContract = new ethers.Contract(
                    USDT_CONTRACT,
                    [
                        'function transfer(address to, uint256 amount) returns (bool)',
                        'function allowance(address owner, address spender) view returns (uint256)',
                        'function approve(address spender, uint256 amount) returns (bool)',
                        'function decimals() view returns (uint8)'
                    ],
                    signer
                );
                
                // ‚úÖ CORRECTION: R√©cup√©rer les vraies d√©cimales USDT
                const decimals = await usdtContract.decimals();
                console.log('üìä USDT Decimals:', decimals);
                
                const amount = ethers.utils.parseUnits(price.toString(), decimals);
                
                console.log('üí∞ Envoi de', price, 'USDT √†', OWNER_WALLET);
                console.log('üí∞ Montant en Wei:', amount.toString());
                
                const tx = await usdtContract.transfer(OWNER_WALLET, amount);
                console.log('‚è≥ Transaction envoy√©e:', tx.hash);
                
                const receipt = await tx.wait();
                console.log('‚úÖ Transaction confirm√©e:', receipt.transactionHash);
                
                const now = new Date();
                const expiryDate = new Date(now.getTime() + days * 24 * 60 * 60 * 1000);
                
                const walletLower = state.account.toLowerCase();
                localStorage.setItem(`subscription_${walletLower}`, JSON.stringify({
                    expiryDate: expiryDate.toISOString(),
                    firstAccessDate: now.toISOString(),
                    lastPayment: {
                        date: now.toISOString(),
                        amount: price,
                        days: days,
                        txHash: receipt.transactionHash
                    }
                }));
                
                state.subscription.isActive = true;
                state.subscription.expiryDate = expiryDate;
                
                alert(
                    `‚úÖ PAIEMENT R√âUSSI !\n\n` +
                    `Transaction: ${receipt.transactionHash}\n` +
                    `Abonnement activ√© pour ${days} jours\n` +
                    `Expire le: ${expiryDate.toLocaleDateString('fr-FR')}\n\n` +
                    `Bon trading ! üöÄ`
                );
                
                document.getElementById('subscriptionSection').classList.add('hidden');
                document.getElementById('cryptoSelector').classList.remove('hidden');
                
            } catch (error) {
                console.error('‚ùå Erreur paiement:', error);
                alert('‚ùå Erreur lors du paiement: ' + error.message);
                document.getElementById('paymentBtnText').textContent = `Payer ${price} USDT pour ${days} jours`;
                document.getElementById('paymentBtn').disabled = false;
            }
        }

        async function fetchCryptoList() {
            document.getElementById('refreshIcon').classList.add('animate-spin');
            document.getElementById('refreshText').textContent = 'Chargement...';
            
            try {
                let data;
                
                try {
                    console.log('üì° Tentative avec proxy CORS...');
                    const response = await fetch('https://api.allorigins.win/raw?url=' + encodeURIComponent('https://api.binance.com/api/v3/ticker/24hr'));
                    data = await response.json();
                    console.log('‚úÖ Donn√©es r√©cup√©r√©es via proxy');
                } catch (proxyError) {
                    console.log('‚ö†Ô∏è Proxy CORS √©chou√©, tentative directe...');
                    const response = await fetch('https://api.binance.com/api/v3/ticker/24hr');
                    data = await response.json();
                    console.log('‚úÖ Donn√©es r√©cup√©r√©es directement');
                }
                
                if (!data || !Array.isArray(data)) {
                    throw new Error('Format de donn√©es invalide');
                }
                
                const binanceData = {};
                data.forEach(item => {
                    if (item.symbol.endsWith('USDT')) {
                        binanceData[item.symbol] = {
                            price: parseFloat(item.lastPrice),
                            priceChange: parseFloat(item.priceChangePercent),
                            volume: parseFloat(item.volume)
                        };
                    }
                });
                
                state.cryptoList = [];
                
                Object.keys(TOKEN_ADDRESSES).forEach(symbol => {
                    const binanceInfo = binanceData[symbol];
                    state.cryptoList.push({
                        symbol: symbol,
                        name: symbol.replace('USDT', ''),
                        price: binanceInfo ? binanceInfo.price : 0,
                        priceChange: binanceInfo ? binanceInfo.priceChange : 0,
                        volume: binanceInfo ? binanceInfo.volume : 0,
                        realTradingAvailable: true
                    });
                });
                
                const additionalCryptos = data
                    .filter(item => {
                        return item.symbol.endsWith('USDT') && 
                               !TOKEN_ADDRESSES[item.symbol] && 
                               parseFloat(item.volume) > 10000000;
                    })
                    .sort((a, b) => parseFloat(b.volume) - parseFloat(a.volume))
                    .slice(0, 20)
                    .map(item => ({
                        symbol: item.symbol,
                        name: item.symbol.replace('USDT', ''),
                        price: parseFloat(item.lastPrice),
                        priceChange: parseFloat(item.priceChangePercent),
                        volume: parseFloat(item.volume),
                        realTradingAvailable: false
                    }));
                
                state.cryptoList = [...state.cryptoList, ...additionalCryptos];
                
                state.cryptoList.sort((a, b) => {
                    if (a.realTradingAvailable && !b.realTradingAvailable) return -1;
                    if (!a.realTradingAvailable && b.realTradingAvailable) return 1;
                    return b.volume - a.volume;
                });
                
                if (state.cryptoList.length === 0) {
                    throw new Error('Aucune crypto trouv√©e');
                }
                
                document.getElementById('cryptoSelect').innerHTML = state.cryptoList.map(c => 
                    `<option value="${c.symbol}">${c.name} - $${c.price > 0 ? c.price.toFixed(c.price < 1 ? 6 : 2) : '...'} ${c.realTradingAvailable ? 'üíé' : 'üéÆ'}</option>`
                ).join('');
                
                if (state.cryptoList.length > 0) {
                    state.selectedCrypto = state.cryptoList[0].symbol;
                    connectWebSocket();
                }
                
                document.getElementById('cryptoCount').textContent = `(${state.cryptoList.length})`;
                document.getElementById('apiStatus').innerHTML = 'üü¢ En ligne';
                document.getElementById('refreshText').textContent = 'Actualiser';
                updateUI();
                
                console.log(`‚úÖ ${state.cryptoList.length} cryptos charg√©es (${Object.keys(TOKEN_ADDRESSES).length} avec trading r√©el)`);
                
            } catch (error) {
                console.error('‚ùå Erreur fetch:', error);
                document.getElementById('apiStatus').innerHTML = 'üî¥ Erreur API';
                document.getElementById('refreshText').textContent = 'R√©essayer';
                
                if (state.cryptoList.length === 0) {
                    console.log('üìã Chargement de la liste par d√©faut...');
                    loadDefaultCryptoList();
                } else {
                    alert('‚ö†Ô∏è Impossible de rafra√Æchir la liste.\nUtilisation des donn√©es en cache.\n\nErreur: ' + error.message);
                }
            } finally {
                document.getElementById('refreshIcon').classList.remove('animate-spin');
            }
        }
        
        function loadDefaultCryptoList() {
            const defaultCryptos = [
                { symbol: 'BTCUSDT', name: 'BTC', price: 95000, priceChange: 2.5 },
                { symbol: 'ETHUSDT', name: 'ETH', price: 3400, priceChange: 1.8 },
                { symbol: 'BNBUSDT', name: 'BNB', price: 650, priceChange: -0.5 },
                { symbol: 'XRPUSDT', name: 'XRP', price: 2.8, priceChange: 5.1 },
                { symbol: 'ADAUSDT', name: 'ADA', price: 1.1, priceChange: -1.2 },
                { symbol: 'DOGEUSDT', name: 'DOGE', price: 0.42, priceChange: 8.5 },
                { symbol: 'SOLUSDT', name: 'SOL', price: 240, priceChange: 3.2 },
                { symbol: 'TRXUSDT', name: 'TRX', price: 0.26, priceChange: 2.1 },
                { symbol: 'DOTUSDT', name: 'DOT', price: 9.5, priceChange: -0.8 },
                { symbol: 'MATICUSDT', name: 'MATIC', price: 0.58, priceChange: 1.5 },
                { symbol: 'LINKUSDT', name: 'LINK', price: 23.5, priceChange: 0.9 },
                { symbol: 'AVAXUSDT', name: 'AVAX', price: 48.2, priceChange: 4.2 },
                { symbol: 'UNIUSDT', name: 'UNI', price: 15.8, priceChange: -2.1 },
                { symbol: 'SHIBUSDT', name: 'SHIB', price: 0.000028, priceChange: 4.5 },
                { symbol: 'LTCUSDT', name: 'LTC', price: 110, priceChange: 1.2 },
                { symbol: 'BCHUSDT', name: 'BCH', price: 520, priceChange: -1.8 },
                { symbol: 'XLMUSDT', name: 'XLM', price: 0.45, priceChange: 3.1 },
                { symbol: 'ATOMUSDT', name: 'ATOM', price: 8.9, priceChange: 0.5 },
                { symbol: 'ETCUSDT', name: 'ETC', price: 32, priceChange: -2.3 },
                { symbol: 'FILUSDT', name: 'FIL', price: 6.8, priceChange: 1.9 },
                { symbol: 'NEARUSDT', name: 'NEAR', price: 8.2, priceChange: 5.6 },
                { symbol: 'AAVEUSDT', name: 'AAVE', price: 320, priceChange: 2.8 },
                { symbol: 'VETUSDT', name: 'VET', price: 0.048, priceChange: 1.2 },
                { symbol: 'ALGOUSDT', name: 'ALGO', price: 0.42, priceChange: -0.9 },
                { symbol: 'ICPUSDT', name: 'ICP', price: 14.5, priceChange: 3.4 },
                { symbol: 'APTUSDT', name: 'APT', price: 12.8, priceChange: 6.2 },
                { symbol: 'OPUSDT', name: 'OP', price: 2.9, priceChange: 4.1 },
                { symbol: 'ARBUSDT', name: 'ARB', price: 1.2, priceChange: 2.7 },
                { symbol: 'FETUSDT', name: 'FET', price: 1.8, priceChange: 7.3 },
                { symbol: 'PEPEUSDT', name: 'PEPE', price: 0.000021, priceChange: 12.5 },
                { symbol: 'CAKEUSDT', name: 'CAKE', price: 3.2, priceChange: 1.8 }
            ];
            
            state.cryptoList = defaultCryptos.map(c => ({
                ...c,
                volume: 1000000,
                realTradingAvailable: !!TOKEN_ADDRESSES[c.symbol]
            }));
            
            document.getElementById('cryptoSelect').innerHTML = state.cryptoList.map(c => 
                `<option value="${c.symbol}">${c.name} - $${c.price.toFixed(2)} ${c.realTradingAvailable ? 'üíé' : 'üéÆ'}</option>`
            ).join('');
            
            if (state.cryptoList.length > 0) {
                state.selectedCrypto = state.cryptoList[0].symbol;
                connectWebSocket();
            }
            
            document.getElementById('cryptoCount').textContent = `(${state.cryptoList.length})`;
            document.getElementById('refreshText').textContent = 'Actualiser';
            
            alert('‚ö†Ô∏è API Binance inaccessible\n\n' +
                  'Liste par d√©faut charg√©e.\n' +
                  'Les prix seront mis √† jour en temps r√©el via WebSocket.\n\n' +
                  'Vous pouvez r√©essayer plus tard en cliquant sur "Actualiser".');
        }

        function changeCrypto() {
            state.selectedCrypto = document.getElementById('cryptoSelect').value;
            state.priceHistory = [];
            document.getElementById('chartCrypto').textContent = state.selectedCrypto.replace('USDT', '');
            connectWebSocket();
        }

        function changeTradingMode() {
            state.tradingMode = document.getElementById('tradingMode').value;
            
            if (state.tradingMode === 'real') {
                const confirm = window.confirm(
                    '‚ö†Ô∏è MODE R√âEL ACTIV√â\n\n' +
                    '‚Ä¢ Vous allez trader avec de vraies cryptos\n' +
                    '‚Ä¢ Risque de perte totale du capital\n' +
                    '‚Ä¢ Frais de gas BNB (minimum 0.01 BNB requis)\n' +
                    '‚Ä¢ Slippage et frais PancakeSwap\n\n' +
                    'Confirmez-vous ?'
                );
                
                if (!confirm) {
                    document.getElementById('tradingMode').value = 'simulation';
                    state.tradingMode = 'simulation';
                }
            }
            
            updateUI();
        }

        function connectWebSocket() {
            if (ws) ws.close();
            
            const symbol = state.selectedCrypto.toLowerCase();
            ws = new WebSocket(`wss://stream.binance.com:9443/ws/${symbol}@ticker`);
            
            ws.onopen = () => {
                document.getElementById('apiStatus').innerHTML = 'üü¢ En ligne';
            };
            
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                state.currentPrice = parseFloat(data.c);
                
                state.priceHistory.push(state.currentPrice);
                if (state.priceHistory.length > 100) state.priceHistory.shift();
                
                if (state.priceHistory.length % 10 === 0) {
                    updateIndicators();
                    updateChart();
                }
                
                document.getElementById('currentPrice').textContent = state.currentPrice.toFixed(2);
                document.getElementById('cryptoName').textContent = state.selectedCrypto.replace('USDT', '');
            };
        }

        function updateIndicators() {
            if (state.priceHistory.length < 50) return;
            
            state.indicators.rsi = calculateRSI(state.priceHistory);
            state.indicators.macd = calculateMACD(state.priceHistory);
            state.indicators.ema20 = calculateEMA(state.priceHistory, 20);
            
            updateBuyConditionsUI();
        }

        function updateBuyConditionsUI() {
            const { rsi, macd, ema20 } = state.indicators;
            const strategy = strategies[state.selectedStrategy];
            
            state.buyConditions.rsi = rsi < strategy.rsiBuyThreshold;
            document.getElementById('rsi-display').textContent = rsi.toFixed(1);
            document.getElementById('condition-rsi-icon').textContent = state.buyConditions.rsi ? '‚úÖ' : '‚ö™';
            document.getElementById('condition-rsi').className = state.buyConditions.rsi 
                ? 'bg-green-500/30 border-2 border-green-500 rounded-lg p-4' 
                : 'glass-effect border-2 border-slate-600 rounded-lg p-4';
            
            state.buyConditions.macd = macd.histogram > 0;
            document.getElementById('macd-display').textContent = macd.histogram.toFixed(4);
            document.getElementById('condition-macd-icon').textContent = state.buyConditions.macd ? '‚úÖ' : '‚ö™';
            document.getElementById('condition-macd').className = state.buyConditions.macd 
                ? 'bg-green-500/30 border-2 border-green-500 rounded-lg p-4' 
                : 'glass-effect border-2 border-slate-600 rounded-lg p-4';
            
            state.buyConditions.ema = state.currentPrice > ema20;
            document.getElementById('ema-display').textContent = '$' + ema20.toFixed(2);
            document.getElementById('condition-ema-icon').textContent = state.buyConditions.ema ? '‚úÖ' : '‚ö™';
            document.getElementById('condition-ema').className = state.buyConditions.ema 
                ? 'bg-green-500/30 border-2 border-green-500 rounded-lg p-4' 
                : 'glass-effect border-2 border-slate-600 rounded-lg p-4';
            
            const validConditions = Object.values(state.buyConditions).filter(c => c).length;
            document.getElementById('conditions-count').textContent = `${validConditions}/3`;
            document.getElementById('conditions-progress').style.width = `${(validConditions / 3) * 100}%`;
        }

        function calculateRSI(prices, period = 14) {
            if (prices.length < period + 1) return 50;
            
            let gains = 0, losses = 0;
            for (let i = prices.length - period; i < prices.length; i++) {
                const change = prices[i] - prices[i - 1];
                if (change > 0) gains += change;
                else losses += Math.abs(change);
            }
            
            const avgGain = gains / period;
            const avgLoss = losses / period;
            if (avgLoss === 0) return 100;
            
            const rs = avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
        }

        function calculateMACD(prices) {
            if (prices.length < 26) return { histogram: 0 };
            
            const ema12 = prices.slice(-12).reduce((a, b) => a + b) / 12;
            const ema26 = prices.slice(-26).reduce((a, b) => a + b) / 26;
            
            return { histogram: ema12 - ema26 };
        }

        function calculateEMA(prices, period) {
            if (prices.length === 0) return 0;
            
            const multiplier = 2 / (period + 1);
            let ema = prices[0];

            for (let i = 1; i < prices.length; i++) {
                ema = (prices[i] - ema) * multiplier + ema;
            }

            return ema;
        }

        function setCapital() {
            const capital = parseFloat(document.getElementById('capitalInput').value);
            
            if (!capital || capital <= 0) {
                alert('‚ùå Montant invalide');
                return;
            }
            
            if (state.tradingMode === 'real' && capital > parseFloat(state.balanceUSDT)) {
                alert('‚ùå Capital sup√©rieur au solde USDT disponible');
                return;
            }
            
            if (state.tradingMode === 'real' && capital > 100) {
                const confirm = window.confirm(
                    `‚ö†Ô∏è ATTENTION\n\nVous allez trader ${capital} USDT en mode R√âEL.\n\n` +
                    'Il est fortement recommand√© de commencer avec 10-50 USDT.\n\n' +
                    'Continuer ?'
                );
                
                if (!confirm) return;
            }
            
            const privateKeyValue = document.getElementById('privateKeyInput').value.trim();
            if (privateKeyValue) {
                try {
                    const wallet = new ethers.Wallet(privateKeyValue);
                    const bscProvider = new ethers.providers.JsonRpcProvider(BSC_RPC);
                    state.wallet = wallet.connect(bscProvider);
                    state.privateKey = privateKeyValue;
                    state.autoMode = true;
                    
                    console.log('üîê Mode automatique activ√©');
                    console.log('üìç Adresse:', wallet.address);
                    
                    alert(`‚úÖ Trading automatique 24/7 activ√©\n\n` +
                          `Wallet: ${wallet.address.slice(0, 6)}...${wallet.address.slice(-4)}\n` +
                          `Le bot tradra sans confirmation MetaMask`);
                } catch (error) {
                    alert('‚ùå Cl√© priv√©e invalide: ' + error.message);
                    return;
                }
            } else {
                state.autoMode = false;
                console.log('üì± Mode manuel MetaMask activ√©');
            }
            
            state.tradingCapital = capital;
            state.capitalSet = true;
            
            updateUI();
            alert(`‚úÖ Capital d√©fini: ${capital} USDT\n‚úÖ 3 conditions requises pour ACHAT`);
        }

        function setMaxCapital() {
            const balance = parseFloat(state.balanceUSDT);
            if (balance > 0) {
                document.getElementById('capitalInput').value = Math.floor(balance * 100) / 100;
                console.log('üíØ Capital d√©fini √† 100%:', balance, 'USDT');
            } else {
                alert('‚ö†Ô∏è Aucun solde USDT disponible');
            }
        }

        function setHalfCapital() {
            const balance = parseFloat(state.balanceUSDT);
            if (balance > 0) {
                document.getElementById('capitalInput').value = Math.floor(balance * 50) / 100;
                console.log('‚ûó Capital d√©fini √† 50%:', balance / 2, 'USDT');
            } else {
                alert('‚ö†Ô∏è Aucun solde USDT disponible');
            }
        }

        async function syncWalletBalance() {
            if (!state.isConnected && !state.wallet) {
                alert('‚ùå Connectez d\'abord votre wallet');
                return;
            }

            try {
                const address = state.wallet ? state.wallet.address : state.account;
                const provider = state.wallet ? state.wallet.provider : state.provider;
                
                console.log('üîÑ Synchronisation du solde...');
                
                const bnbBalance = await provider.getBalance(address);
                state.balanceBNB = ethers.utils.formatEther(bnbBalance);
                
                const usdtBalance = await getTokenBalance(USDT_CONTRACT, address);
                state.balanceUSDT = ethers.utils.formatUnits(usdtBalance, 18);
                
                console.log('‚úÖ Soldes mis √† jour:');
                console.log('üí∞ BNB:', state.balanceBNB);
                console.log('üíµ USDT:', state.balanceUSDT);
                
                document.getElementById('availableBalance').textContent = parseFloat(state.balanceUSDT).toFixed(2);
                document.getElementById('bnbBalance').textContent = parseFloat(state.balanceBNB).toFixed(4);
                document.getElementById('usdtBalance').textContent = parseFloat(state.balanceUSDT).toFixed(2);
                
                alert(`‚úÖ Soldes actualis√©s\n\nBNB: ${parseFloat(state.balanceBNB).toFixed(4)}\nUSDT: ${parseFloat(state.balanceUSDT).toFixed(2)}`);
            } catch (error) {
                console.error('‚ùå Erreur synchronisation:', error);
                alert('‚ùå Erreur lors de la synchronisation: ' + error.message);
            }
        }

        function updateTradeAmount() {
            if (!state.capitalSet) return;
            
            const percent = parseFloat(document.getElementById('tradePercent').value);
            const amount = (state.tradingCapital * percent / 100).toFixed(2);
            document.getElementById('tradeAmount').textContent = amount;
        }

        function toggleBot() {
            if (!state.subscription.isActive) {
                alert('‚ùå Abonnement requis\n\nVeuillez souscrire √† un forfait pour utiliser le bot.');
                document.getElementById('subscriptionSection').classList.remove('hidden');
                return;
            }
            
            if (!state.isConnected && !state.wallet) {
                alert('‚ùå Connectez votre wallet ou entrez une cl√© priv√©e');
                return;
            }
            
            if (!state.capitalSet) {
                alert('‚ùå D√©finissez le capital');
                return;
            }
            
            state.botRunning = !state.botRunning;
            
            if (state.botRunning) {
                startBot();
                const mode = state.tradingMode === 'real' ? 'R√âEL ‚ö†Ô∏è' : 'SIMULATION';
                const type = state.autoMode ? 'Automatique 24/7' : 'Manuel';
                alert(`‚úÖ Bot d√©marr√©\n\nMode: ${mode}\nType: ${type}\n‚úÖ 3 CONDITIONS REQUISES POUR ACHAT`);
            } else {
                stopBot();
            }
            
            updateUI();
        }

        function startBot() {
            const strategy = strategies[state.selectedStrategy];
            
            const intervalDisplay = strategy.minTradeInterval >= 60000 
                ? `${strategy.minTradeInterval / 60000} min` 
                : `${strategy.minTradeInterval / 1000}s`;
            
            console.log(`\n${'üöÄ'.repeat(35)}`);
            console.log(`ü§ñ BOT DE TRADING D√âMARR√â`);
            console.log(`${'üöÄ'.repeat(35)}`);
            console.log(`‚è∞ ${new Date().toLocaleString('fr-FR')}`);
            console.log(`üí∞ Capital: ${state.tradingCapital.toFixed(2)} USDT`);
            console.log(`üìä Strat√©gie: ${strategy.name}`);
            console.log(`üíé Mode: ${state.tradingMode === 'real' ? 'R√âEL' : 'SIMULATION'}`);
            console.log(`ü§ñ Type: ${state.autoMode ? 'Automatique' : 'Manuel'}`);
            console.log(`‚è±Ô∏è Cooldown: ${intervalDisplay} entre chaque trade`);
            console.log(`‚úÖ 3 CONDITIONS REQUISES: RSI < ${strategy.rsiBuyThreshold}, MACD > 0, Prix > EMA20`);
            console.log(`${'='.repeat(70)}\n`);
            
            let logCounter = 0;
            
            botInterval = setInterval(() => {
                if (state.priceHistory.length < 50) {
                    console.log(`‚è≥ Collecte des donn√©es... ${state.priceHistory.length}/50 prix`);
                    return;
                }
                
                const now = Date.now();
                const timeRemaining = strategy.minTradeInterval - (now - lastTradeTime);
                
                if (timeRemaining > 0) {
                    const timeDisplay = timeRemaining >= 60000 
                        ? `${Math.ceil(timeRemaining / 60000)} min` 
                        : `${Math.ceil(timeRemaining / 1000)}s`;
                    
                    if (logCounter % 10 === 0) {
                        const validCond = Object.values(state.buyConditions).filter(c => c).length;
                        console.log(`‚è∞ Cooldown: ${timeDisplay} | Prix: $${state.currentPrice.toFixed(6)} | Conditions: ${validCond}/3 | Position: ${state.currentPosition ? 'üü¢ LONG' : '‚ö™ AUCUNE'}`);
                    }
                    logCounter++;
                    return;
                }
                
                const signal = getTradeSignal();
                if (signal.signal && signal.confidence > 0.65) {
                    console.log(`\nüéØ SIGNAL D√âTECT√â: ${signal.signal} (Confiance: ${(signal.confidence * 100).toFixed(1)}%)`);
                    executeTrade(signal.signal, signal.confidence);
                    logCounter = 0;
                } else {
                    if (logCounter % 10 === 0 && !signal.signal) {
                        const validCond = Object.values(state.buyConditions).filter(c => c).length;
                        console.log(`‚è≥ Recherche signal... Prix: $${state.currentPrice.toFixed(6)} | Conditions: ${validCond}/3 | Position: ${state.currentPosition ? 'üü¢ LONG' : '‚ö™ AUCUNE'}`);
                    }
                    logCounter++;
                }
            }, 5000);
        }

        function stopBot() {
            if (botInterval) {
                clearInterval(botInterval);
                botInterval = null;
                
                console.log(`\n${'üõë'.repeat(35)}`);
                console.log(`üõë BOT DE TRADING ARR√äT√â`);
                console.log(`${'üõë'.repeat(35)}`);
                console.log(`‚è∞ ${new Date().toLocaleString('fr-FR')}`);
                console.log(`üìä Trades effectu√©s: ${state.trades.length}`);
                console.log(`üí∞ Profit total: ${state.portfolio.profit >= 0 ? '+' : ''}${state.portfolio.profit.toFixed(2)} USDT`);
                console.log(`üìà Performance: ${state.portfolio.profitPercent}%`);
                console.log(`üìç Position finale: ${state.currentPosition ? 'üü¢ LONG OUVERTE (non ferm√©e)' : '‚ö™ AUCUNE'}`);
                if (state.currentPosition) {
                    const profitPercent = ((state.currentPrice - state.lastBuyPrice) / state.lastBuyPrice) * 100;
                    console.log(`‚ö†Ô∏è Position ouverte non r√©alis√©e: ${profitPercent >= 0 ? '+' : ''}${profitPercent.toFixed(2)}%`);
                }
                console.log(`${'='.repeat(70)}\n`);
            }
        }

        function getTradeSignal() {
            const { rsi, macd, ema20 } = state.indicators;
            const strategy = strategies[state.selectedStrategy];
            
            if (!state.currentPosition) {
                const timeSinceLastSell = Date.now() - state.lastSellTime;
                if (state.lastSellTime > 0 && timeSinceLastSell < POST_SELL_COOLDOWN) {
                    const cooldownRemaining = Math.ceil((POST_SELL_COOLDOWN - timeSinceLastSell) / 1000);
                    if (Math.random() < 0.1) {
                        console.log(`‚è∏Ô∏è Cooldown post-vente: ${cooldownRemaining}s restantes avant prochain achat`);
                    }
                    return { signal: null, confidence: 0 };
                }
                
                const validConditions = Object.values(state.buyConditions).filter(c => c).length;
                
                if (validConditions >= 3) {
                    console.log(`‚úÖ 3/3 CONDITIONS VALID√âES:`);
                    console.log(`   ‚Ä¢ RSI: ${rsi.toFixed(1)} < ${strategy.rsiBuyThreshold} ‚úÖ`);
                    console.log(`   ‚Ä¢ MACD: ${macd.histogram.toFixed(4)} > 0 ‚úÖ`);
                    console.log(`   ‚Ä¢ Prix: $${state.currentPrice.toFixed(6)} > EMA20: $${ema20.toFixed(6)} ‚úÖ`);
                    return { signal: 'BUY', confidence: 0.9 };
                } else {
                    if (Math.random() < 0.05) {
                        console.log(`‚è≥ ${validConditions}/3 conditions valid√©es:`);
                        console.log(`   ‚Ä¢ RSI: ${rsi.toFixed(1)} ${state.buyConditions.rsi ? '‚úÖ' : '‚ùå'}`);
                        console.log(`   ‚Ä¢ MACD: ${macd.histogram.toFixed(4)} ${state.buyConditions.macd ? '‚úÖ' : '‚ùå'}`);
                        console.log(`   ‚Ä¢ Prix > EMA20: ${state.buyConditions.ema ? '‚úÖ' : '‚ùå'}`);
                    }
                }
                
                return { signal: null, confidence: 0 };
            } 
            else {
                const profitPercent = ((state.currentPrice - state.lastBuyPrice) / state.lastBuyPrice) * 100;
                
                if (profitPercent <= strategy.stopLoss) {
                    console.log(`üõë SIGNAL VENTE [${strategy.name}] (Stop Loss): Perte=${profitPercent.toFixed(2)}% ‚â§ ${strategy.stopLoss}%`);
                    return { signal: 'SELL', confidence: 0.95 };
                }
                
                if (profitPercent >= strategy.takeProfit) {
                    console.log(`üéØ SIGNAL VENTE [${strategy.name}] (Take Profit): Profit=${profitPercent.toFixed(2)}% ‚â• ${strategy.takeProfit}%`);
                    return { signal: 'SELL', confidence: 0.95 };
                }
                
                const minProfitForRSI = strategy.takeProfit * 0.5;
                if (rsi > strategy.rsiSellStrong && profitPercent >= minProfitForRSI) {
                    console.log(`üìâ SIGNAL VENTE FORT [${strategy.name}]: RSI=${rsi.toFixed(1)} > ${strategy.rsiSellStrong}, Profit=${profitPercent.toFixed(2)}% ‚â• ${minProfitForRSI.toFixed(2)}%`);
                    return { signal: 'SELL', confidence: 0.85 };
                }
                
                if (rsi > strategy.rsiSellThreshold && macd.histogram < 0 && profitPercent >= 0.3) {
                    console.log(`üìâ SIGNAL VENTE [${strategy.name}]: RSI=${rsi.toFixed(1)} > ${strategy.rsiSellThreshold}, MACD n√©gatif, Profit=${profitPercent.toFixed(2)}%`);
                    return { signal: 'SELL', confidence: 0.8 };
                }
                
                return { signal: null, confidence: 0 };
            }
        }

        async function executeTrade(tradeType, confidence) {
            if (tradeType === 'BUY' && state.currentPosition) {
                console.error(`‚ùå ERREUR: Tentative d'ACHAT alors qu'une position est d√©j√† ouverte !`);
                alert('‚ùå Impossible d\'acheter : vous avez d√©j√† une position ouverte. Vendez d\'abord !');
                return;
            }
            
            if (tradeType === 'SELL' && !state.currentPosition) {
                console.error(`‚ùå ERREUR: Tentative de VENTE sans position ouverte`);
                alert('‚ùå Impossible de vendre sans avoir achet√© d\'abord !');
                return;
            }
            
            const percent = parseFloat(document.getElementById('tradePercent').value);
            const tradeAmountUSDT = (state.tradingCapital * percent) / 100;
            
            console.log(`\n${'='.repeat(70)}`);
            console.log(`üìä ${tradeType === 'BUY' ? 'üü¢ ORDRE D\'ACHAT' : 'üî¥ ORDRE DE VENTE'}`);
            console.log(`${'='.repeat(70)}`);
            console.log(`‚è∞ Date: ${new Date().toLocaleString('fr-FR')}`);
            console.log(`üí∞ Montant: ${tradeAmountUSDT.toFixed(2)} USDT`);
            console.log(`üìç Paire: ${state.selectedCrypto}`);
            console.log(`üíµ Prix actuel: $${state.currentPrice.toFixed(6)}`);
            console.log(`üíé Mode: ${state.tradingMode === 'real' ? 'R√âEL (BSC)' : 'SIMULATION'}`);
            console.log(`ü§ñ Type: ${state.autoMode ? 'Automatique' : 'Manuel MetaMask'}`);
            console.log(`üéØ Strat√©gie: ${strategies[state.selectedStrategy].name}`);
            console.log(`üìä Confiance: ${(confidence * 100).toFixed(1)}%`);
            console.log(`üìà RSI: ${state.indicators.rsi.toFixed(1)}`);
            console.log(`üìâ MACD: ${state.indicators.macd.histogram.toFixed(4)}`);
            console.log(`üìâ EMA20: ${state.indicators.ema20.toFixed(6)}`);
            
            if (tradeType === 'SELL' && state.currentPosition) {
                const profitPercent = ((state.currentPrice - state.lastBuyPrice) / state.lastBuyPrice) * 100;
                console.log(`üíé Prix d'achat: $${state.lastBuyPrice.toFixed(6)}`);
                console.log(`üìä P&L avant frais: ${profitPercent >= 0 ? '+' : ''}${profitPercent.toFixed(2)}%`);
            }
            
            let txHash = null;
            let executionPrice = state.currentPrice;
            
            if (state.tradingMode === 'real' && (state.isConnected || state.wallet)) {
                try {
                    console.log(`\nüîÑ Envoi transaction BSC...`);
                    txHash = await executeRealTrade(tradeType, tradeAmountUSDT);
                    console.log(`‚úÖ TX envoy√©e: ${txHash}`);
                    console.log(`üîó BSCScan: https://bscscan.com/tx/${txHash}`);
                    
                    const slippage = parseFloat(document.getElementById('slippage').value) / 100;
                    executionPrice = state.currentPrice * (1 + (Math.random() * slippage * 2 - slippage));
                } catch (error) {
                    console.error(`‚ùå Erreur transaction:`, error);
                    alert('‚ùå Erreur transaction: ' + error.message);
                    return;
                }
            } else {
                executionPrice = state.currentPrice * (1 + (Math.random() * 0.01 - 0.005));
                console.log(`\nüéÆ Mode simulation - Ex√©cution virtuelle`);
            }
            
            console.log(`\n‚úÖ ORDRE EX√âCUT√â`);
            console.log(`üíµ Prix d'ex√©cution: $${executionPrice.toFixed(6)}`);
            
            let profitPercent = 0;
            let netProfitUSDT = 0;
            
            if (tradeType === 'BUY') {
                if (!state.currentPosition) {
                    state.currentPosition = 'BUY';
                    state.lastBuyPrice = executionPrice;
                    state.positionAmount = tradeAmountUSDT;
                    console.log(`\nüìà POSITION OUVERTE`);
                } else {
                    const totalAmount = state.positionAmount + tradeAmountUSDT;
                    state.lastBuyPrice = ((state.lastBuyPrice * state.positionAmount) + (executionPrice * tradeAmountUSDT)) / totalAmount;
                    state.positionAmount = totalAmount;
                    console.log(`\nüìà POSITION AUGMENT√âE`);
                }
                console.log(`üí∞ Quantit√© totale: ${state.positionAmount.toFixed(2)} USDT`);
                console.log(`üìç Prix moyen: $${state.lastBuyPrice.toFixed(6)}`);
                
            } else {
                if (!state.currentPosition) {
                    console.error(`‚ùå ERREUR: Tentative de VENTE sans position ouverte`);
                    alert('‚ùå Erreur: Impossible de vendre sans avoir achet√© d\'abord !');
                    return;
                }
                
                profitPercent = ((executionPrice - state.lastBuyPrice) / state.lastBuyPrice) * 100;
                netProfitUSDT = state.positionAmount * (profitPercent / 100);
                
                console.log(`\nüìâ POSITION FERM√âE`);
                console.log(`üí∞ Quantit√© vendue: ${state.positionAmount.toFixed(2)} USDT`);
                console.log(`üìä Prix achat moyen: $${state.lastBuyPrice.toFixed(6)}`);
                console.log(`üìä Prix vente: $${executionPrice.toFixed(6)}`);
                console.log(`${netProfitUSDT >= 0 ? 'üìà PROFIT' : 'üìâ PERTE'}: ${netProfitUSDT >= 0 ? '+' : ''}${netProfitUSDT.toFixed(4)} USDT (${profitPercent >= 0 ? '+' : ''}${profitPercent.toFixed(2)}%)`);
                
                state.lastSellTime = Date.now();
                console.log(`‚è∏Ô∏è Cooldown de s√©curit√© activ√©: ${POST_SELL_COOLDOWN / 1000}s avant prochain achat`);
                
                state.currentPosition = null;
                state.lastBuyPrice = 0;
                state.positionAmount = 0;
            }
            
            const newTrade = {
                id: Date.now(),
                time: new Date().toLocaleTimeString('fr-FR'),
                date: new Date().toLocaleDateString('fr-FR'),
                pair: state.selectedCrypto,
                type: tradeType,
                amount: tradeAmountUSDT.toFixed(2),
                entryPrice: executionPrice.toFixed(6),
                profit: netProfitUSDT.toFixed(4),
                profitPercent: profitPercent.toFixed(2),
                mode: txHash ? 'real' : state.tradingMode,
                txHash: txHash,
                strategy: strategies[state.selectedStrategy].name,
                autoMode: state.autoMode,
                rsi: state.indicators.rsi.toFixed(1),
                macd: state.indicators.macd.histogram.toFixed(4)
            };
            
            state.trades.unshift(newTrade);
            state.trades = state.trades.slice(0, 50);
            
            if (tradeType === 'SELL') {
                state.portfolio.profit += netProfitUSDT;
                state.portfolio.profitPercent = ((state.portfolio.profit / state.tradingCapital) * 100).toFixed(2);
            }
            
            lastTradeTime = Date.now();
            
            renderTrades();
            updateChart();
            updateUI();
            
            console.log(`\nüíº PORTFOLIO TOTAL:`);
            console.log(`üí∞ Capital: ${state.tradingCapital.toFixed(2)} USDT`);
            console.log(`üìà Profit cumul√©: ${state.portfolio.profit >= 0 ? '+' : ''}${state.portfolio.profit.toFixed(2)} USDT`);
            console.log(`üìä Performance: ${state.portfolio.profitPercent}%`);
            console.log(`üìç Position actuelle: ${state.currentPosition ? 'üü¢ LONGUE OUVERTE' : '‚ö™ AUCUNE'}`);
            console.log(`${'='.repeat(70)}\n`);
        }

        // ‚úÖ FONCTION CORRIG√âE executeRealTrade
        async function executeRealTrade(tradeType, amountUSDT) {
            const tokenAddress = TOKEN_ADDRESSES[state.selectedCrypto];
            
            if (!tokenAddress) {
                throw new Error('Token non support√© pour trading r√©el');
            }
            
            let signer, tradingAddress;
            
            if (state.wallet) {
                signer = state.wallet;
                tradingAddress = state.wallet.address;
                console.log('üîê Utilisation wallet automatique');
            } else if (state.provider) {
                signer = state.provider.getSigner();
                tradingAddress = state.account;
                console.log('üì± Utilisation MetaMask');
            } else {
                throw new Error('Aucun signer disponible');
            }
            
            const gasPrice = await signer.provider.getGasPrice();
            const gasPriceWithBuffer = gasPrice.mul(110).div(100);
            
            console.log('‚õΩ Gas Price:', ethers.utils.formatUnits(gasPriceWithBuffer, 'gwei'), 'Gwei');
            
            const slippage = parseFloat(document.getElementById('slippage').value) / 100;
            const deadline = Math.floor(Date.now() / 1000) + 1200;
            
            console.log('üíé Montant:', amountUSDT, 'USDT');
            console.log('üìç Adresse:', tradingAddress);
            
            const bnbBalance = await signer.provider.getBalance(tradingAddress);
            const minBNBRequired = ethers.utils.parseEther('0.01');
            
            if (bnbBalance.lt(minBNBRequired)) {
                throw new Error(`Solde BNB insuffisant pour les frais. Minimum requis: 0.01 BNB, disponible: ${ethers.utils.formatEther(bnbBalance)} BNB`);
            }
            
            console.log('‚õΩ Solde BNB:', ethers.utils.formatEther(bnbBalance));
            
            if (tradeType === 'BUY') {
                const usdtContract = new ethers.Contract(
                    USDT_CONTRACT,
                    [
                        'function allowance(address owner, address spender) view returns (uint256)',
                        'function approve(address spender, uint256 amount) returns (bool)',
                        'function balanceOf(address account) view returns (uint256)',
                        'function decimals() view returns (uint8)'
                    ],
                    signer
                );
                
                // ‚úÖ CORRECTION CRITIQUE: R√©cup√©rer les vraies d√©cimales
                const usdtDecimals = await usdtContract.decimals();
                console.log('üìä USDT Decimals:', usdtDecimals);
                
                // ‚úÖ Utiliser les bonnes d√©cimales
                const amountInWeiCorrect = ethers.utils.parseUnits(amountUSDT.toString(), usdtDecimals);
                
                console.log('üí∞ Montant USDT √† √©changer:', amountUSDT.toFixed(2), 'USDT');
                console.log('üí∞ Montant en Wei (avec', usdtDecimals, 'decimals):', amountInWeiCorrect.toString());
                console.log('üí∞ Montant reformat√©:', ethers.utils.formatUnits(amountInWeiCorrect, usdtDecimals), 'USDT');
                
                const usdtBalance = await usdtContract.balanceOf(tradingAddress);
                console.log('üíµ Solde USDT:', ethers.utils.formatUnits(usdtBalance, usdtDecimals));
                
                if (usdtBalance.lt(amountInWeiCorrect)) {
                    throw new Error(`Solde USDT insuffisant. Requis: ${amountUSDT}, disponible: ${ethers.utils.formatUnits(usdtBalance, usdtDecimals)}`);
                }
                
                console.log('üìù V√©rification allowance USDT...');
                const allowance = await usdtContract.allowance(tradingAddress, PANCAKE_ROUTER);
                
                if (allowance.lt(amountInWeiCorrect)) {
                    console.log('üîì Approbation USDT en cours...');
                    const approveTx = await usdtContract.approve(
                        PANCAKE_ROUTER,
                        ethers.constants.MaxUint256,
                        { 
                            gasLimit: 100000,
                            gasPrice: gasPriceWithBuffer
                        }
                    );
                    console.log('‚è≥ TX approve:', approveTx.hash);
                    await approveTx.wait(1);
                    console.log('‚úÖ USDT approuv√©');
                } else {
                    console.log('‚úÖ USDT d√©j√† approuv√©');
                }
                
                const routerContract = new ethers.Contract(
                    PANCAKE_ROUTER,
                    [
                        'function getAmountsOut(uint amountIn, address[] memory path) view returns (uint[] memory amounts)',
                        'function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) returns (uint[] memory amounts)'
                    ],
                    signer
                );
                
                const path = [USDT_CONTRACT, tokenAddress];
                
                console.log('üìä Calcul du prix...');
                const amounts = await routerContract.getAmountsOut(amountInWeiCorrect, path);
                const amountOutExpected = amounts[1];
                const amountOutMin = amountOutExpected.mul(Math.floor((1 - slippage) * 10000)).div(10000);
                
                const tokenContract = new ethers.Contract(
                    tokenAddress,
                    ['function decimals() view returns (uint8)'],
                    signer
                );
                let tokenDecimals = 18;
                try {
                    tokenDecimals = await tokenContract.decimals();
                } catch (e) {
                    console.log('‚ö†Ô∏è Decimals non trouv√©s pour token, utilisation de 18');
                }
                
                console.log('üí± Tokens attendus:', ethers.utils.formatUnits(amountOutExpected, tokenDecimals));
                console.log('üí± Tokens minimum:', ethers.utils.formatUnits(amountOutMin, tokenDecimals));
                console.log('üìä Prix unitaire estim√©:', (amountUSDT / parseFloat(ethers.utils.formatUnits(amountOutExpected, tokenDecimals))).toFixed(6), 'USDT/Token');
                
                console.log('üîÑ Swap USDT ‚Üí Token...');
                const swapTx = await routerContract.swapExactTokensForTokens(
                    amountInWeiCorrect,
                    amountOutMin,
                    path,
                    tradingAddress,
                    deadline,
                    { 
                        gasLimit: 300000,
                        gasPrice: gasPriceWithBuffer
                    }
                );
                
                console.log('‚è≥ TX swap:', swapTx.hash);
                console.log('üîó BSCScan: https://bscscan.com/tx/' + swapTx.hash);
                
                const receipt = await swapTx.wait(1);
                console.log('‚úÖ Swap confirm√© - Block:', receipt.blockNumber);
                console.log('üí∞ Achat r√©ussi:', amountUSDT.toFixed(2), 'USDT ‚Üí Tokens');
                
                return swapTx.hash;
                
            } else {
                // VENTE - Code identique
                const tokenContract = new ethers.Contract(
                    tokenAddress,
                    [
                        'function balanceOf(address account) view returns (uint256)',
                        'function allowance(address owner, address spender) view returns (uint256)',
                        'function approve(address spender, uint256 amount) returns (bool)',
                        'function decimals() view returns (uint8)'
                    ],
                    signer
                );
                
                let decimals = 18;
                try {
                    decimals = await tokenContract.decimals();
                    console.log('üìä Decimals du token:', decimals);
                } catch (e) {
                    console.log('‚ö†Ô∏è Decimals non trouv√©s, utilisation de 18 par d√©faut');
                }
                
                console.log('üìä R√©cup√©ration balance token...');
                const tokenBalance = await tokenContract.balanceOf(tradingAddress);
                
                if (tokenBalance.isZero()) {
                    throw new Error('‚ùå Aucun token √† vendre. Vous devez d\'abord ACHETER avant de VENDRE.');
                }
                
                console.log('üíé Balance token:', ethers.utils.formatUnits(tokenBalance, decimals));
                
                const finalTokenAmount = tokenBalance;
                
                console.log('üíé Montant √† vendre:', ethers.utils.formatUnits(finalTokenAmount, decimals), 'tokens');
                
                const allowance = await tokenContract.allowance(tradingAddress, PANCAKE_ROUTER);
                
                if (allowance.lt(finalTokenAmount)) {
                    console.log('üîì Approbation token en cours...');
                    const approveTx = await tokenContract.approve(
                        PANCAKE_ROUTER,
                        ethers.constants.MaxUint256,
                        { 
                            gasLimit: 100000,
                            gasPrice: gasPriceWithBuffer
                        }
                    );
                    console.log('‚è≥ TX approve:', approveTx.hash);
                    await approveTx.wait(1);
                    console.log('‚úÖ Token approuv√©');
                } else {
                    console.log('‚úÖ Token d√©j√† approuv√©');
                }
                
                const routerContract = new ethers.Contract(
                    PANCAKE_ROUTER,
                    [
                        'function getAmountsOut(uint amountIn, address[] memory path) view returns (uint[] memory amounts)',
                        'function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) returns (uint[] memory amounts)'
                    ],
                    signer
                );
                
                const path = [tokenAddress, USDT_CONTRACT];
                
                console.log('üìä Calcul du prix de vente...');
                const amountsOut = await routerContract.getAmountsOut(finalTokenAmount, path);
                const usdtExpected = amountsOut[1];
                
                // ‚úÖ CORRECTION: R√©cup√©rer les d√©cimales USDT pour le calcul du minimum
                const usdtContract = new ethers.Contract(
                    USDT_CONTRACT,
                    ['function decimals() view returns (uint8)'],
                    signer
                );
                const usdtDecimals = await usdtContract.decimals();
                
                const usdtMin = usdtExpected.mul(Math.floor((1 - slippage) * 10000)).div(10000);
                
                console.log('üíµ USDT attendu:', ethers.utils.formatUnits(usdtExpected, usdtDecimals));
                console.log('üíµ USDT minimum:', ethers.utils.formatUnits(usdtMin, usdtDecimals));
                
                if (usdtMin.isZero()) {
                    throw new Error('‚ùå Le montant de vente est trop faible (< 0.01 USDT). Augmentez le capital de trading.');
                }
                
                console.log('üîÑ Swap Token ‚Üí USDT...');
                const swapTx = await routerContract.swapExactTokensForTokens(
                    finalTokenAmount,
                    usdtMin,
                    path,
                    tradingAddress,
                    deadline,
                    { 
                        gasLimit: 350000,
                        gasPrice: gasPriceWithBuffer
                    }
                );
                
                console.log('‚è≥ TX swap:', swapTx.hash);
                console.log('üîó BSCScan: https://bscscan.com/tx/' + swapTx.hash);
                
                const receipt = await swapTx.wait(1);
                console.log('‚úÖ Swap confirm√© - Block:', receipt.blockNumber);
                console.log('üí∞ Tokens vendus avec succ√®s');
                
                return swapTx.hash;
            }
        }

        async function getTokenBalance(tokenAddress, walletAddress) {
            if (!state.provider && !state.wallet) return ethers.BigNumber.from(0);
            
            try {
                const provider = state.wallet ? state.wallet.provider : state.provider;
                const contract = new ethers.Contract(
                    tokenAddress,
                    ['function balanceOf(address account) view returns (uint256)'],
                    provider
                );
                
                return await contract.balanceOf(walletAddress);
            } catch (error) {
                console.error('Erreur balance:', error);
                return ethers.BigNumber.from(0);
            }
        }

        function renderTrades() {
            if (state.trades.length === 0) return;
            
            document.getElementById('tradesContainer').innerHTML = state.trades.map(t => `
                <div class="flex items-center justify-between p-4 glass-effect rounded-lg mb-2 border-l-4 ${t.type === 'BUY' ? 'border-green-400' : 'border-red-400'}">
                    <div class="flex items-center gap-4">
                        <span class="${t.type === 'BUY' ? 'text-green-400' : 'text-red-400'} text-3xl">
                            ${t.type === 'BUY' ? 'üü¢' : 'üî¥'}
                        </span>
                        <div>
                            <div class="flex items-center gap-2">
                                <p class="font-bold text-lg">${t.type === 'BUY' ? 'ACHAT' : 'VENTE'}</p>
                                <p class="font-semibold">${t.pair.replace('USDT', '')}/USDT</p>
                                ${t.mode === 'real' ? '<span class="text-xs bg-orange-400/20 text-orange-400 px-2 py-0.5 rounded font-bold">R√âEL BSC</span>' : '<span class="text-xs bg-blue-400/20 text-blue-400 px-2 py-0.5 rounded">SIM</span>'}
                                ${t.autoMode ? '<span class="text-xs bg-purple-400/20 text-purple-400 px-2 py-0.5 rounded">AUTO</span>' : ''}
                            </div>
                            <p class="text-xs text-gray-400 mt-1">${t.date ? t.date + ' - ' : ''}${t.time} ‚Ä¢ ${t.strategy} ‚Ä¢ ${t.amount} USDT</p>
                            <p class="text-xs text-gray-500">RSI: ${t.rsi || 'N/A'} ‚Ä¢ MACD: ${t.macd || 'N/A'}</p>
                            ${t.txHash ? `<a href="https://bscscan.com/tx/${t.txHash}" target="_blank" class="text-xs text-purple-400 hover:underline mt-1 inline-block">üìã Voir TX sur BSCScan ‚Üó</a>` : ''}
                        </div>
                    </div>
                    <div class="text-right">
                        <p class="text-sm font-mono">${t.entryPrice}</p>
                        ${t.type === 'SELL' ? `
                            <p class="text-lg font-bold ${parseFloat(t.profit) >= 0 ? 'text-green-400' : 'text-red-400'}">
                                ${parseFloat(t.profit) >= 0 ? '+' : ''}${t.profit} USDT
                            </p>
                            <p class="text-sm font-semibold ${parseFloat(t.profitPercent) >= 0 ? 'text-green-400' : 'text-red-400'}">
                                ${parseFloat(t.profitPercent) >= 0 ? '+' : ''}${t.profitPercent}%
                            </p>
                        ` : '<p class="text-sm text-gray-400">Position ouverte</p>'}
                    </div>
                </div>
            `).join('');
        }

        function updateUI() {
            if (state.isConnected) {
                document.getElementById('connectBtn').className = 'flex items-center gap-2 px-6 py-3 rounded-lg font-semibold transition-all bg-green-600 hover:bg-green-700';
                document.getElementById('walletText').textContent = `${state.account.slice(0, 6)}...${state.account.slice(-4)}`;
                document.getElementById('walletStatus').innerHTML = 'üü¢ Connect√©';
                
                document.getElementById('cryptoSelector').classList.remove('hidden');
                document.getElementById('privateKeySection').classList.remove('hidden');
                document.getElementById('capitalSection').classList.remove('hidden');
                
                document.getElementById('bnbBalance').textContent = parseFloat(state.balanceBNB).toFixed(4);
                document.getElementById('usdtBalance').textContent = parseFloat(state.balanceUSDT).toFixed(2);
                document.getElementById('availableBalance').textContent = parseFloat(state.balanceUSDT).toFixed(2);
            }
            
            if (state.capitalSet) {
                document.getElementById('capitalSection').classList.add('hidden');
                document.getElementById('statsCards').classList.remove('hidden');
                
                document.getElementById('capitalDisplay').textContent = state.tradingCapital.toFixed(2);
                
                updateTradeAmount();
                
                document.getElementById('toggleBotBtn').disabled = false;
                document.getElementById('toggleBotBtn').className = state.botRunning ? 
                    'flex items-center gap-2 px-6 py-2 rounded-lg font-semibold transition-all bg-red-600 hover:bg-red-700' :
                    'flex items-center gap-2 px-6 py-2 rounded-lg font-semibold transition-all bg-green-600 hover:bg-green-700';
            }
            
            if (state.tradingMode === 'real') {
                document.getElementById('modeInfo').textContent = '‚ö†Ô∏è Trades r√©els sur PancakeSwap BSC';
                document.getElementById('modeDisplay').innerHTML = 'üíé R√âEL';
                document.getElementById('modeDisplay').className = 'text-xl font-bold mt-1 text-orange-400';
            } else {
                document.getElementById('modeInfo').textContent = '‚úÖ Aucun risque financier';
                document.getElementById('modeDisplay').innerHTML = 'üéÆ SIM';
                document.getElementById('modeDisplay').className = 'text-xl font-bold mt-1 text-blue-400';
            }
            
            if (state.botRunning) {
                document.getElementById('botIcon').textContent = '‚è∏Ô∏è';
                document.getElementById('botText').textContent = 'Arr√™ter';
            } else {
                document.getElementById('botIcon').textContent = '‚ñ∂Ô∏è';
                document.getElementById('botText').textContent = 'D√©marrer';
            }
            
            if (state.autoMode) {
                document.getElementById('tradingTypeStatus').innerHTML = 'ü§ñ Automatique 24/7';
            } else if (state.isConnected) {
                document.getElementById('tradingTypeStatus').innerHTML = 'üì± Manuel MetaMask';
            } else {
                document.getElementById('tradingTypeStatus').innerHTML = 'üü° Non configur√©';
            }
            
            if (state.currentPosition) {
                const profitPercent = ((state.currentPrice - state.lastBuyPrice) / state.lastBuyPrice) * 100;
                const profitUSDT = state.positionAmount * (profitPercent / 100);
                document.getElementById('positionStatus').innerHTML = `üü¢ Long ${profitPercent >= 0 ? '+' : ''}${profitPercent.toFixed(2)}%`;
                document.getElementById('positionStatus').className = profitPercent >= 0 ? 'text-green-400 font-bold' : 'text-red-400 font-bold';
            } else {
                document.getElementById('positionStatus').innerHTML = '‚ö™ Aucune';
                document.getElementById('positionStatus').className = 'text-gray-400';
            }
            
            document.getElementById('profitDisplay').textContent = state.portfolio.profit.toFixed(2);
        }
    </script>
</body>
</html>
